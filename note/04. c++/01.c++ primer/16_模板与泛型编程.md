&emsp;&emsp;所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。模板是泛型编程的基础。使用模板时可以无须了解模板的定义。
&emsp;&emsp;泛型编程与面向对象的编程一样，都依赖于某种形式的多态性。面向对象编程中的多态性利用虚函数的动态绑定，使用基类的指针或引用可以访问基类类型或派生类类型对象的成员函数。
&emsp;&emsp;在泛型编程中，我们所编写的类和函数能够多态地用于跨越编译时不相关的类型。一个类或函数可以用来操作多种类型的对象。标准库中的容器、迭代器和算法是很好的泛型编程的例子。标准库用独立于类型的方式定义每个容器、迭代器和算法，因此几乎可以在任意类型上使用标准库的类和函数。
&emsp;&emsp;在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。
## 16.1 模板定义
&emsp;&emsp;假设想要编写一个函数比较两个值并指出第一个值是小于、等于还是大于第二值。在实践中，我们可能希望定义几个这样的函数，每一个可以比较给定类型的值，第一次尝试可能是定义几个重载函数：
```language
int compare(const string &v1, const string &v2)
{
	if (v1 < v2) return -1;
    if (v1 > v2) return 1;
    return 0;
}

int compare(const double &v1, const double &v2)
{
	if (v1 < v2) return -1;
    if (v1 > v2) return 1;
    return 0;
}
```
这些函数几乎相同，它们之间唯一的区别是形参的类型，每个函数的函数体是相同。每个要比较的类型都需要重复函数的函数体，不仅麻烦而且容易出错。更重要的是，需要事先知道究竟可能会比较哪些类型。
&emsp;&emsp;为了解决上述问题，提出了函数模板和类模板。***函数模板和类模板可以在不同类型之间实现相同的操作***

### 16.1.1 定义函数模板
&emsp;&emsp;我们可以不用为每个类型定义一个新函数，而是只定义一个函数模板（function template）。函数模板是一个独立于类型的函数，可以作为一种方式，产生函数的特定类型版本。模板定义以template开始，后接模板形参表（template parameter list），模板形参表示是用尖括号括住的一个或多个模板形参（template parameter)的列表，形参之间以逗号分隔。
&emsp;&emsp;下面是compare的模板版本：
```language
template <typename T>
int compare(const T &v1, const T &v2)
{
	if (v1 < v2) return -1;
    if (v1 < v2) return 1;
    return 0;
}
```
> 模板形参表不能为空。

** 1. 模板形参表**
&emsp;&emsp;模板形参可以是表示类型的**类型形参**（type parameter），也可以是表示常量表达式的**非类型形参**（nontype parameter）。非类型形参跟在类型说明符之后声明。类型形参跟在关键字typename或class之后定义。例如class T是名为T的类型形参，在这里class和typename没有区别。
** 2. 使用函数模板**
&emsp;&emsp;使用函数模板时，编译器会推断哪一个模板实参绑定到模板形参。一旦编译器确定了实际的模板实参，就称它为**实例化**了函数模板的一个实例。
&emsp;&emsp;实质上，编译器将确定用什么类型代替每个类型形参，以及用什么值代替每个非类型形参。推导出实际模板实参后，编译器使用实参代替相应的模板形参产生并编译该版本的函数。编译器承担了为我们使用的每种类型编写函数的单调工作。
** 3. inline函数模板**
&emsp;&emsp;函数模板可以用与非模板函数一样的方式声明inline。说明符放在模板形参表之后，返回类型之前，不能放在关键字template之前。
### 16.1.2 定义类模板
&emsp;&emsp;就像可以定义函数模板一样，也可以定义类模板。
&emsp;&emsp;类模板也是模板，因此必须以关键字template开头，后接模板形参表。除了模板形参表之外，类模板的定义看起来与一般类类型定义并无区别。类模板可以定义数据成员、函数成员和类型成员，也可以使用访问标号控制对成员的访问，还可以定义构造函数和析构函数。
&emsp;&emsp;与调用函数模板形成鲜明的对比，使用类模板时，必须为模板形参显示指定形参。
```language
Queue<int> q1;
Queue<vector<double>> qc;
Queue<string> qs;
```
### 16.1.3 模板形参
&emsp;&emsp;像模板形参一样，模板形参的名字没有本质含义。可以给模板形参赋予唯一含义是区别形参是类型形参还是非类型形参。如果是类型形参，我们就知道该形参表示未知类型，如果是非类型形参，表示一个未知值。
** 1. 模板形参作用域**
&emsp;&emsp;模板形参的名字可以在声明为模板形参之后到模板声明或定义的末尾处使用。
&emsp;&emsp;模板形参遵循常规的名字屏蔽规则。与全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字。
```language
typedef double T;
template<class T> T clac(const T &a, const T &b)
{
	// tmp has the type of the template parameter T
    // not that of the global typedef
    T tmp = a;
    // ...
    return tmp;
}
```
将T定义为double的全局类型别名将会被名为T的类型形参所屏蔽。tmp不是double类型，而是被绑定到模板形参的任意类型。
** 2. 使用模板形参名字的限制**
&emsp;&emsp;用作模板形参的名字不能在模板内部重用：
```language
template <class T> T calc(const T &a, const T &b)
{
	typedef double T; // error: redeclares template parameter T
    T  tmp = a;
    // ...
}
```
** 3. 模板声明**
&emsp;&emsp;像其他任意函数或类一样，对于模板可以只声明而不定义。声明必须指出函数或类是一个模板：
```language
template <class T> int compare(const T &a, const T &b);
```
### 16.1.4 模板类型形参
**1. typename与class的区别**
&emsp;&emsp;在函数模板形参表中，关键字typename和class具有相同的含义，可以互换使用，两个关键字都可以在同一模板形参表中使用。
**2. 在模板类型内部定义指定类型**
&emsp;&emsp;如果类模板需要使用形参中的类型成员，必须显式的告诉编译器该成员为类型成员而不是数据成员。默认情况下，编译器假定这样的名字为数据成员而不是类型成员。通过在成员名前加上关键字typename作为前缀，显式的告诉编译器将成员当做类型。
```language
template<class Param, class U>
Param fcn(Param* array, U value)
{
	typename Param::size_type *p;
}
```
### 16.1.5 非类型模板形参
&emsp;&emsp;在调用函数时非类型形参将用值代替，值的类型在模板形参表中指定。例如：
```language
template <class T, size_t N> void array_init(T (&parm)[N])
{
	for (size_t i = 0; i != N; ++i)
    {
    	parm[i] = 0;
    }
}
```
模板非类型形参是模板定义内部的常量值，在需要常量表达式的时候，可以使用非类型形参指定数组的长度。
&emsp;&emsp;当调用array_init时，编译器从数组实参计算非类型形参的值。
int x[42];
double y[10];
array_init(x[42])；  // instantiates array_init(int(&)[42])
array_init(y[10]);   // instantiates array_init(double(&)[10])

## 16.2 实例化
&emsp;&emsp;类模板不定义类型，只有特定的实例才定义类型。特定的实例化是通过提供模板实参与每个模板形参相匹配。
**1. 形参包含多个类型，实参必须与形参的每个类型匹配**
```language
template <typename T>
int compare(const T& v1, const T& v2)
{
	if (v1 < v2) return -1;
    if (v1 < v2) return 1;
    return 0;
}
int main()
{
	short si = 10;
    compare(si, 1024);
    return 0;
}
```
**2. 实参到模板类型形参的受限转换**
&emsp;&emsp;一般而言，不会转换实参以匹配已有的实例化，相反，会产生新的实例。除了产生新的实例化之外，编译器只会执行两种转换：
* const转换：接受const引用或const指针的函数，可以接受非const引用或非const指针。如果函数形参为非const类型，可以接受const类型和非const类型实参。
* 数组和函数到指针转换：如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。数组实参将当做指向第一个元素的指针，函数实参当做指向函数类型的指针。

> 数组形参的定义：
> void printValue(int *){/* ... */}
> void printValue(int[]){/* ... */}
> void printValue(int[10]){/* ... */}
> 编译器忽略为任何数组形参指定长度。
> 当数组形参为非引用时，此时数组会被隐式转换为指针。一般来说，非引用类型的形参会初始化为其相应实参的副本。而在传递数组时，实参是指向数组第一个元素的指针，形参复制的是这个指针的值，而不是数组元素本身。
> 当数组形参是引用时，编译器不会把数组实参转化为指针，而是传递数组引用本身。此时，数组大小为形参和实参类型的一部分。编译器会检查数组实参的大小与形参的大小是否匹配。通过引用传递数组，需要限制数组的大小，不灵活。

**3. 模板中非类型形参支持常规转换**
&emsp;&emsp;用普通类型定义的形参可以使用常规转换，下面的函数模板sum有两个形参：
```language
template <class Type> Type sum(const Type &op1, int op2)
{
	return op1 + op2;
}
```
第一个形参op1具有模板形参类型，它的实际类型到函数使用的时候才知道。第二个形参op2的类型已知，为int。因为op2的类型固定，支持常规的类型转换。
```language
double d = 3.14;
string s1("hiya"), s2("world");
sum(1024, d); // ok: convert double to int
sum(s1, s2);  // error: s2 not convert string to int
```
第二个函数错误，因为不存在从string到int的转换。
### 16.2.2 函数模板的显式实参
&emsp;&emsp;可以在函数模板中动态指定返回值的类型，但是需要在实例化的过程中显式指定。因为在调用函数的时候，没有办法确定返回值的类型。有时为了避免歧义，需要显式指定形参的类型。
```language
template <class T1, class T2, class T2>
T1 sum(T2, T3)
{
	return T2 + T3;
}
long val3 = sum<long>(10, 2); // 显式调用函数模板
// 显示指定函数模板的形参避免歧义
template <typename T> int compare(const T&, const T&);
void func(int (*)(const string&, const string&));
void func(int (*)(cosnt int&, const int&));
func(compare<int>);
```
如果不显式指定compare中形参类型，在调用func函数的时候有两个重载版本可以选择，都可以进行实例化，编译器不会区分哪一个更好，就
出现了二义性。当显式指定compare中形参类型，compare直接实现了实例化。
## 16.3 模板编译模型
&emsp;&emsp;当编译器看到模板定义的时候，它不立即产生代码。只有在看到用到模板的时候，如调用了函数模板或类模板的时候，编译器才产生特定类型的模板实例。
&emsp;&emsp;一般而言，当调用函数的时候，编译器只需要看到函数的声明。类似地，定义类类型对象的时候，类定义必须可用，但是成员函数的定义不是必须存在。因此，应该将类定义和函数声明放在头文件中，而普通函数和类成员函数的定义放在源文件中。
&emsp;&emsp;模板则不同：要进行实例化，编译器必须能够访问定义模板的源代码。当调用函数的模板或类模板的成员函数的时候，编译器需要函数定义，需要访问函数定义的源代码。
&emsp;&emsp;标准C++为编译模板代码定义了两种模型。在这两种模型中，构造程序的方式是相同的：类定义和函数声明放在头文件中，而函数的定义和成员函数的定义放在源文件中。两种模型的不同在于，编译器怎样使用来自源文件的定义。一种为包含模型，一种为分别编译模型。
***包含模型和分别编译模型不做具体的阐述，可以参考课本543页。***
## 16.4 类模板成员
### 16.4.1 类模板成员函数
&emsp;&emsp;类模板成员函数的定义具有如下形式：
* 必须以关键字template开头，后接类的模板形参表。
* 必须指出它是哪个类的成员。
* 类名必须包含其模板形参。

** 1. 类模板成员函数的的实例化**
&emsp;&emsp;类模板的成员函数本身也是函数模板。像任何其他函数模板一样，需要实例化。与函数模板实例化不同的是，在实例化类模板成员函数的时候，编译器不执行模板类型形参的推断，因为在实例化类对象的时候，模板类型形参已经确定了。
** 2. 实例化类和成员的时机**
&emsp;&emsp;类模板的成员函数只有在第一次调用的时候才实例化。如果某函数从未使用，则不会实例化该成员函数。在定义类模板类型对象的时候，该定义会实例化类模板，同时实例化用于初始化该对象的任意构造函数，以及该构造函数调用的任一成员。**由于书中并没有提到在定义类模板类对象的时候，是否实例化数据成员，按道理说应该实例化数据成员，因为定义类模板对象的时候会实例化构造函数，构造函数会初始化数据成员。**


