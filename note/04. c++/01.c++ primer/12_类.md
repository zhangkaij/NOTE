## 12.1 类的定义和声明
&emsp;&emsp;在类内部定义的函数默认为inline。内联函数会在编译时被展开，避免函数调用的开销（内联函数只是建议展开，编译器也可以选择忽略这个建议）。
&emsp;&emsp;***内联函数应该在头文件中定义（指非类成员函数）***。内联函数的定义对编译器而言必须是可见的，以便编译器能够在调用点内联的展开。此时，仅有函数原型是不够的。内联函数可能出现在多个源文件中，但是要求定义必须完全相同，因此把内联函数放在头文件中。一般来说，内联机制使用于优化小、只有几行的而且经常被调用的函数。大多数编译器都不支持递归函数的内联。一个1200行的函数也不太可能在调用点内联展开。
### 12.1.2 数据抽象和封装
&emsp;&emsp;**类背后蕴藏的基本思想为数据抽象和封装**。
&emsp;&emsp;数据抽象是一种依赖于接口和实现分离的编程技术。类设计者必须关心类是如何实现的，但是使用该类的程序员不必了解这些细节。
&emsp;&emsp;封装是一项将低层次的元素组合起来形成新的、高层次实体的技术。函数是封装的一种形式，函数所执行的细节被封装在函数本身这个更大的实体中，被封装的元素隐藏了他们的实现细节。类也是一个封装的实体，它代表若干成员的聚集，大多数类类型隐藏了实现该类型的成员。
&emsp;&emsp;**抽象把一个整体分离为多个个体，而封装是把多个分离的个体组合一个整体**。
&emsp;&emsp;如果类是用struct关键字定义的，则在第一个访问标号之前的成员是public；如果类是用class关键字定义的，则这些成员是私有的。
### 12.1.4 类的声明和定义
&emsp;&emsp;一旦遇到右花括号，类的定义就结束了。并且一旦定义了类，我们就知道类成员，以及存储该类的对象所用的存储空间。把类放在头文件中，可以保证在每个使用类的文件中都以同样的方式定义类。
&emsp;&emsp;可以声明一个类而不定义它。
```language
	class Screen; // declaration of the Screen class
```
这个声明，有时称为***前向声明***（forward declaration），在程序中引入了类类型Screen。在声明之后、定义之前，类Screen被称为不完全类型，即已知Screen是一个类型，但是不知道包含哪些成员。
> 不完全类型只能以有限的方式使用。不能创建该类型的对象。不完全类型只能用于定义指向该类型的指针和引用，或者用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数。类的前向声明一般用于编写相互依赖的类。

** 为类的成员使用类声明 **
&emsp;&emsp;只用类被定义，类的数据成员才能指定该类类型。如果该类是不完全类型，那么数据成员只能是该类类型的指针或引用。
&emsp;&emsp;因为只有当类定义体完成后才能定义类，因此类不能具有自身类型的数据成员。然而，只要类名一出现就可以认为该类已声明。因此，类的数据成员可以指向类本身的指针或引用。
```c++
class LinkScreen{
	Screen window;
    LinkScreen *next;
    LinkScreen *prev;
}
```
### 12.1.5 类对象
&emsp;&emsp;定义一个类时，就是定义一个类型。一旦定义了类，就可以定义该类型的对象。定义对象时将为其分配存储空间，但是定义类型时一般不为其分配存储空间。每个对象具有自己的类数据成员的副本，也就是说，其分配的存储空间为为类数据成员的大小。

## 12.2 隐含的this指针
&emsp;&emsp;成员函数具有一个附加的隐含形参，即指向该类对象的一个指针，这个隐含形参命名为this。
**返回*this**
&emsp;&emsp;有些成员函数必须返回一个引用，该引用指向执行操作的那个对象。
```c++
Screen& Screen::move(index r, index r)
{
	...
    return *this;
}
```
**从const成员函数返回*this** 
&emsp;&emsp;在普通的非const成员函数中，this是一个指向类类型的const指针，可以改变this所指向的对象的值，但是不可以改变this所保存的地址。在const成员函数中，this的类型是一个const对象的const指针。
**可变数据成员**
&emsp;&emsp;在const成员函数中，类的数据成员一般不可以改变。但是有时出于需要，部分数据成员即使在const成员函数中也能够改变，需要在这样的数据成员前面添加关键字**mutable**。
## 12.3 类作用域
```
作用域操作符    ::
成员访问操作符  .或->
```
&emsp;&emsp;类中成员的访问：数据成员或成员函数，通过成员访问操作符访问；自己定义的类型成员，通用作用域操作符访问。
&emsp;&emsp;每个类都定义了自己的新的作用域和唯一的类型。在类的定义体内声明类成员，将成员名引入类的作用域。两个不同的类具有两个不同的作用域。即使在类外定义的成员函数，由于使用完全限定名，该成员函数也在该类的定义域内。
&emsp;&emsp;如果成员函数在类外定义，由于形参和函数体在函数名之后，也处于类的定义域内。但是返回值的类型处于类的定义域外。如果返回值的类型为类定义的类型，则必须使用完全限定名。

## 12.4 构造函数
&emsp;&emsp;与任何其他函数一样，构造函数具有名字、形参表和函数体。与其他函数不同的是，构造函数还可以包含一个构造函数初始化列表：
```c++
Sales_item::Sales_item(const string &book):
	isbn(book), units_sold(0), revenue(0.0) {}
```
构造函数的初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟着一个放在圆括号中的初始化式。构造函数初始化式只在构造函数的定义中而不是声明中指定。**构造函数的函数体是对数据成员进行赋值，不是初始化，只有初始化列表才算初始化**。
### 12.4.1 有时需要构造函数初始化列表
&emsp;&emsp;如果没有为类提供初始化式，则编译器会隐式的调用成员类型的默认构造函数。如果那个类型没有默认的构造函数，则编译器会报错。
> 有些成员必须在构造函数的初始化列表中进行初始化。该类型的成员包括：没有默认构造函数的类类型成员，以及const或引用类型的成员。

### 12.4.2 成员初始化的次序
&emsp;&emsp;成员初始化的次序就是定义成员的次序。第一个首先被初始化，其次式第二个，依次类推。尽量不要使用数据成员初始化另外一个数据成员，会引起莫名其妙的问题。比如：
```language
class x{
	int i;
    int j;
    public:
    	x(int val):j(val), i(j){ }
};
```
在这种情况下，构造函数的初始化列表看起来是先用val初始化j，然后用j初始化i。实际是，先用未初始化的j初始化i...
### 12.4.3 默认构造函数
&emsp;&emsp;只要定义一个类类型的对象没有提供初始化值，就使用默认构造函数。为所有形参提供默认值的构造函数也是一种默认构造函数。
**合成的默认构造函数**
&emsp;&emsp;一个类只要定义了一个构造函数，编译器就不会生成默认构造函数。该规则的根据是，如果一个类在某种情况下需要控制对象的初始化，则该类很可能在所有情况下都需要控制。
***合成的默认构造函数***使用与变量初始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数来进行初始化。内置和复合类型如指针和数组，只对定义在全局作用域中的对象才初始化。当对象定义在局部作用域内时，内置或复合的数据类型不进行初始化。
**类通常应定义一个默认构造函数**
&emsp;&emsp;在某些情况下，默认构造函数时有编译器隐式应用的。如果类没有默认构造函数，在许多情况下就不可以使用该类。为了示例，假定有一个NoDefault类，它没有定义自己的默认构造函数，却有一个接受一个string实参的构造函数。由于此类定义了一个构造函数，因此编译器不会合成默认构造函数。NoDefault没有默认构造函数，意味着：
* 具有NoDefault成员的每个类的每个构造函数，必须通过传递一个初始的string值给NoDefault构造函数来显示地初始化NoDefault成员；
* 编译器不会为含有NoDefault类型成员的类合成默认构造函数。如果这样的类希望提供默认构造函数，必须自己构造；
* NoDefault不能用作动态分配数组元素类型；
* NoDefault静态分配数组必须为每个元素提供一个显示的初始值；
* 如果有一个保存NoDefault对象的容器，例如vector，就不能使用接受容器大小而没有同时提供元素初始化式的构造函数。

### 12.4.4 隐式类类型转换
&emsp;&emsp;可以用只含有单个形参的构造函数来实现从实参到该类类型的一个隐式转换。比如：
```language
class Scales_item{
public:
	Sales_item(const std::string &book = ""):
    	isbn(book), units_sold(0), revenue(0.0) { }
};
```
这里的构造函数定义了一个隐式转换。因此在期待一个Sales_item类型对象的地方，可以使用一个string：
string null_book = ”9-999-9999“；
item.same_isbn(null_book);
这段程序使用一个string类型对象作为实参传递给same_isbn函数。该函数期待一个Sales_item对象作为实参。编译器使用接受一个string的Sales_item构造函数从null_book生成一个新的Sales_item对象。新生成的（临时的）Sales_item被传递给same_isbn。
**抑制由构造函数定义的隐式转换**
可以通过将构造函数声明为explicit，来防止在需要隐式转换的上下文中使用构造函数：
```language
class Sales_item{
public:
	explicit Sales_item(const std::string &book):
    	isbn(book), units_sold(0), revenue(0.0) { }
}
```
explicit关键字只能用于类内部的构造函数声明上。在类的定义体外部所做的定义上不再重复它。
**为转换显式地使用构造函数**
### 类成员的显式初始化
&emsp;&emsp;尽管大多数对象可以通过运行适当的构造函数进行初始化，但是直接初始化简单的非抽象类的数据成员仍然是可能的。
```language
struct Data{
	int ival;
    
    int *ptr;
};
Data val = {0, null};
```
这种初始化缺点较多，按照数据成员定义的顺序初始化，如果增加或删除某个成员，所有调用的地方都必须修改，不宜于维护。

## 12.5 友元
&emsp;&emsp;在某些情况下，与某个类无关的函数需要访问该类的私有成员，同时仍然阻止一般的访问，使用**友元**机制可以很好的解决该问题。友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字friend开始。它只能出现在类定义的内部。友元声明可以出现在类中任何地方，友元不是授予友元关系的那个类的成员。**通常将友元成组的放在类的开始或结尾是个好主意**。可以使***类或类的一个成员函数***成为友元。
## 12.5.3 友元声明与作用域
&emsp;&emsp;为了正确的构造类，需要注意友元声明与友元定义之间的互相依赖。只能先定义，才能声明为友元。然而，只有先声明，类或函数才能访问私有数据。更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。如果一个函数由多个重载函数，那么必须把所有的函数都设为友元。

## 12.6 static类成员
&emsp;&emsp;有时为了协调一个类的多个对象，需要定义全局对象。但是全局对象会破环封装，一次引入***类静态成员***。
&emsp;&emsp;通常，非static数据成员存在于类类型的每个对象中。static数据成员独立于该类的任一对象而存在（应该在完成定义之后就分配了内存空间）。每个static数据成员是与类关联的对象，不是与该类的对象相关联。也可以定义static成员函数，static成员函数没有this形参，它可以直接访问所属类的static成员，但是不可以访问所属类的非static成员。
&emsp;&emsp;只需要在成员前面添加关键字**static**，即为类静态成员。如果静态成员函数在类的外部定义，无需重复指定static保留字，只需要在类定义体内部的声明处出现即可。
&emsp;&emsp;static成员是类的组成部分但不是任何对象的组成部分，因此，static成员函数没有this指针。（因为this指针指向的是调用该成员函数的对象，而static成员函数属于类，在static成员函数创建的时候，可能还没有创建与该类相关的任何对象）
&emsp;&emsp;**static数据成员**必须在类的外部定义，在类的内部声明，static成员不能通过构造函数初始化，而是在定义时初始化。
> 变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。
> 变量的声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量的时候我们声明了它的类型和名字。声明包括对象名、对象类型和关键字extern。
> ```C++
> extern int i; // declares but does not define i
> int i;        // declares and define i
>```
>只有当声明也是定义的时候，声明才可以有初始化式，因为只有定义才分配存储空间。如果声明有初始化式，那么它被当作是定义，即使含有声明标记extern。

**1. 特殊的整型const static成员**
&emsp;&emsp;const staitc数据成员可以在类的定义体中初始化，但是必须在类的定义体外定义。static数据成员可以当作默认实参。非static数据成员不可以当作默认实参。























