&emsp;&emsp;面向对象编程（object-orientedprogramming， OOP)基于三个基本概念：数据抽象，继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个类：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。
## 15.1 面向对象编程：概述
&emsp;&emsp;面向对象的关键思想是**多态性**。
** 1. 继承**
&emsp;&emsp;通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。**派生类**能够继承**基类**的成员，派生类可以调用和覆盖基类的成员函数，派生类可以定义与自己相关的成员函数。在C++中，***多态性仅用于通过继承而相关联的类型的指针或引用***。我们经常称因继承而相关的类构成一个**继承层次**。其中一个类称为根，其他类直接或间接继承根类。
** 2. 动态绑定**
&emsp;&emsp;通过动态绑定我们能够编写程序使用继承层次中任意类型的对象，无需关心对象的具体类型。使用这些类的函数无需区分函数是在基类中定义还是在派生类中定义的。
> 在c++中，通过基类的引用（或指针）调用**虚函数**时，发生动态绑定。引用（或指针）即可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。

## 15.2 定义基类和派生类
&emsp;&emsp;为了指明函数为虚函数，在其返回类型前面加上保留字virtual。***除了构造函数之外，任意非static成员函数都可以是虚函数***。保留字virtual只在类内部的成员函数声明中出现，不能用在类定义体外部出现的函数定义上。
&emsp;&emsp;用户代码可以访问类的public成员，但是不可以访问类的private成员。类的private成员只可以由自身类成员和友元访问，派生类也不可以访问基类的private成员。派生类可以访问基类的public和protected成员。
### 15.2.3 派生类
&emsp;&emsp;为了定义派生类，使用类派生列表指定基类。类派生列表指定一个或多个基类，具有如下形式：
class classname: access-label base-class
这里access-label是public、private或protected。
&emsp;&emsp;一般情况下，派生类会重定义基类的虚函数。如果派生类没有定义某个虚函数，则使用基类中定义的版本。派生类中虚函数的声明必须与基类中的定义方式完全匹配--函数名，形参类型和形参个数必须一致，但是有一个例外：返回对基类型的引用（或指针）的虚函数，在派生类中被重写之后可以返回派生类的引用（或指针）。
&emsp;&emsp;只有已经定义的类才可以用作基类。如果类仅仅声明而没有定义，并不可以当做基类。如果需要声明派生类，则声明包含类名但不包含派生列表。

### 15.2.4 virtual与其他成员函数
&emsp;&emsp;C++中的函数默认不使用动态绑定。要触发动态绑定，必须满足两个条件：第一，只有指定虚函数的成员函数才可以进行动态绑定；第二，必须通过基类类型的指针或引用进行函数调用。
**1. 从派生类到基类的转换**
&emsp;&emsp;因为每个派生类对象都包含基类部分，所以可以将基类的引用绑定到派生类对象的基类部分，也可以用指向基类的指针指向派生类对象。
&emsp;&emsp;因为可以使用基类类型的指针或引用来引用派生类型对象，所以使用基类类型的指针或引用时，不知道指针或引用所绑定的对象的实际类型。基类类型的指针或引用可以绑定基类类型的对象，也可以绑定派生类类型的对象。无论实际对象是哪一种类型，编译器都把它当做基类类型对象。
> 基类类型引用和指针的关键点在于静态类型（static type，在编译时可知的引用类型或指针类型）和动态类型（dynamic type，指针或引用所绑定的对象的类型，这是仅在运行时可知的）可能不同。

**2. 可以在运行时确定virtual函数的调用**
&emsp;&emsp;将基类类型的引用或指针绑定到派生类对象对对象没有影响，对象本身不会发生改变，认为派生类对象。对象的实际类型可能不同于该对象引用或指针的静态类型，这是c++动态绑定的关键。
&emsp;&emsp;通过引用或指针调用虚函数时，编译器按照静态类型生成代码，在运行时动态确定调用哪一个函数，被调用的是与动态类型相对应的函数。
> C++中的多态性
> 引用和指针的静态类型与动态类型可以不同，这是C++支持多态性的基石。
> 通过基类的指针或引用调用基类中的函数的时候，我们并不知道执行函数的确切类型，执行函数的对象可以是基类类型，也可以是派生类类型。
> 如果调用非虚函数，无论实际对象是什么类型，都执行基类类型所定义的函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定的或指针所指向的对象所属类型定义的版本。


**3. 在编译时确定非virtual调用**
&emsp;&emsp;非虚函数总是在编译时根据调用该函数的对象、引用或指针的类型而确定。
**4. 覆盖虚函数调用机制**
&emsp;&emsp;在某些情况下，希望覆盖虚函数调用机制并强制函数调用使用虚函数的特定版本，这是可以使用作用域操作符（::）。比如：
```language
Item_base *baseP = &derived;
// call version from the base class regardless of the dynamic type of baseP
double d = baseP->Item_base::net_price(42);
```
&emsp;&emsp;为什么会希望覆盖虚函数机制？如果已经知道是调用基类还是派生类中的虚函数，因此不需要通过虚函数机制。
**5. 虚函数与默认实参**
&emsp;&emsp;虚函数可以有默认实参。在基类和派生类中同一虚函数最好具有相同的默认实参。否则，因为通过基类的指针或引用调用派生类对象时，因为编译时使用的是静态类型（也就是基类虚函数的默认实参），而运行时使用的动态类型（也就是派生类的默认实参），会引起莫名其妙的问题。

### 15.2.5 公用、私有和受保护的继承
&emsp;&emsp;对类所继承的成员的访问由基类中的成员访问级别和派生类派生列表中使用的访问标号共同控制。
> 每个类控制它所定义的成员的访问。派生类可以进一步限制但是不能放松对所继承成员的访问。

&emsp;&emsp;派生类不能访问基类的private成员。如果基类成员为public或protected，则派生列表中使用的访问标号决定该成员在派生类中的访问级别。
* 公用继承（public inheritance），基类成员保持自己的访问级别：基类的public成员为派生类的public成员，基类的protected成员为派生类的protected成员。
* 受保护继承（protected inheritance），基类的public和protected成员在派生类中均为protected成员。
* 私有成员（private inheritance），基类的public和protected成员在派生类中均为private成员。

> 派生访问标号将控制派生类的用户对从base继承而来的成员的访问级别。

**1. 接口继承与实现继承**
&emsp;&emsp;public派生类继承基类的接口，它具有与基类相同的接口。设计良好的类层次中，public派生类的对象可以用在任何需要基类的地方。
&emsp;&emsp;使用private或protected派生的类不继承类的接口--即派生类的用户不能访问基类的成员，相反，这些派生通常称为实现继承。派生类在实现中使用被继承类但是被继承基类的部分并没有称为其接口的一部分。
> 迄今为止，最常见的继承形式是public。

**2. 去除个别成员**
&emsp;&emsp;如果使用protected或private继承，则基类成员的访问级别在派生类中比在基类中更受限。
```language
class Base{
public:
	size_t size() const { return n; }
protected:
	size_t n;
};
class Derived: private Base { ... };
```
size在基类中为public，在派生类Derived中为private。为了使size在Derived中恢复基类中的访问级别，可以在派生类中相应的访问级别增加一个using声明。***派生类可以恢复被继承成员的访问级别，但是不能使访问级别比基类中的访问级别更高或更低***。
```language
class Derived: private Base {
public:
	using Base::size;
protected:
	using Base::in;
    //...
};
```

**3. 默认继承保护级别**
&emsp;&emsp；class和struct的默认继承级别和默认访问级别一致。使用class保留字定义的派生类默认具有private继承，而用struct保留字定义的类默认具有public继承。

###15.2.6 友元关系与继承

&emsp;&emsp;友元关系不能继承。基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，不具有访问派生类的特殊权限。

### 15.2.7 基类与静态成员
&emsp;&emsp;如果基类定义了一个static成员，则整个继承层次中只有一个这样的成员。无论从基类中派生出多少个派生类，每个static成员只有一个实例。static成员遵循常规的访问控制：如果成员为基类中private，则派生类不能访问它。

## 15.3 转换与继承
&emsp;&emsp;基类类型对象既可以作为独立对象存在，也可以作为派生类对象的一部分存在，因此，一个基类对象可能是也可能不是一个派生类对象的部分，结果，没有从基类引用（或基类指针）到派生类引用（或派生类指针）的（自动）转换--类型转换和指针（或引用）的动态绑定不同，动态绑定并没有改变对象的类型。相对于引用或指针而言，对象转换的情况更加复杂，虽然可以使用派生类对象对基类对象进行初始化或赋值，但是，没有从派生类对象到基类类型对象的直接转换。



### 15.3.1 派生类到基类的转换
* 如果有一个派生类类型的对象，可以使用它的地址对基类类型的指针进行赋值或初始化。
* 同理，可以使用派生类类型的对象或引用来初始化基类类型的引用。
* 编译器不会自动将派生类类型对象转换为基类类型对象。
* 一般可以使用派生类类型对象对基类类型对象进行赋值或初始化。

**1. 引用转换不同于对象转换**
&emsp;&emsp;我们已经看到，可以将派生类型的对象传给希望接受基类引用的函数。也许会因此认为发生了对象转换，但是，事实并非如此。将对象传给希望接受引用的函数时，引用直接绑定到该对象，实际上实参是该对象的引用，对象本身并没有被复制，并且，没有在任何方面改变派生类型的对象，该对象仍为派生类型的对象。
&emsp;&emsp;将派生类对象传给希望接收基类类型对象的函数时，情况完全不同。在这种情况下，形参的类型是固定的--在编译时和运行时形参都是基类类型对象。如果用派生类对象为实参调用该函数，则该派生类的基类部分被复制到形参--调用复制构造函数创建一个基类对象。
**2. 使用派生类对象对基类对象进行初始化或赋值**
&emsp;&emsp;对基类对象进行初始化或赋值，实际上是调用函数：初始化时调用构造函数，赋值时调用赋值操作符。用派生类对象对基类对象初始化或赋值，可以采用如下方法：
* 基类显式定义了将派生类对象到基类对象的复制构造函数和赋值操作符，一般没有人这样做。
* 使用基类的复制构造函数和赋值操作符，这两个函数都接受一个基类类型的引用作为参数。

**3. 派生类到基类转换的可访问性**
&emsp;&emsp;从派生类到基类的转换可能是也可能不是可访问的。因为该转换是调用基类的复制构造函数和赋值操作符，只有用户可以访问这两个函数，在可以进行从派生类到基类的转换。
### 15.3.2 基类到派生类的转换
&emsp;&emsp;基类到派生类的自动转换是不存在的。需要派生类对象的时候不能使用基类对象。因为基类对象只包含部分派生类的成员。如果允许用基类对象给派生类对象赋值，那么就可以试图使用该派生类对象访问不存在的成员。
&emsp;&emsp;有时更令人惊讶，甚至基类指针或引用实际绑定的就是派生类对象，从基类到派生类的转换也受限制。
```language
Bulk_item bulk;
Item_base *pitem = &bulk; // ok:dynamic type is Bulk_item
Bulk_item *pbulk = pitem; // error:cann't convert base to derived
```
编译器在编译时无法知道特定转换在运行时是安全的。编译器确定转换是否合法，只看指针或引用的静态类型。在这种情况下，可以使用static_cast强制编译器进行转换。或者，可以用dynamic_cast申请在运行时进行检查。
##15.4 构造函数和复制控制
&emsp;&emsp;***构造函数和复制控制成员不能继承***，每个类定义自己的构造函数和复制控制成员。

###15.4.2 派生类构造函数
&emsp;&emsp;派生类构造函数受继承关系的影响，每个派生类构造函数除了初始化自己的数据成员之外，还要初始化基类的。
**1. 合成的派生类默认构造函数**
&emsp;&emsp;派生类的合成默认构造函数与非派生类的构造函数只有一点不同：除了初始化派生类的数据成员之外，还要初始化基类的数据成员。
**2. 定义默认构造函数**
&emsp;&emsp;因为Bulk_item具有内置类型成员，所以应定义自己的默认构造函数：
```language
class Bulk_item: public Item_base{
public:
	Bulk_item(): min_qty(0), discount(0.0) { }
private:
	size_t min_qty;
    float discount;
};
```
这个构造函数使用构造函数初始化列表初始化min_qty和discount成员，该构造函数还隐式调用Item_base的默认构造函数初始化对象的基类部分。
&emsp;&emsp;运行这个构造函数的效果是，首先使用基类Item_base的默认构造函数来初始化基类的成员。在Item_base的构造函数执行完毕后，再初始化派生类Bulk_item定义的数据成员，并执行构造函数的函数体。
**3. 向基类构造函数提供实参**
&emsp;&emsp;在派生类的构造函数中可以显式调用基类任一构造函数，并且可以为基类构造函数提供实参。派生类构造函数的初始化列表只能初始化派生类定义的成员，不能直接初始化继承成员。但是，派生类构造函数可以将基类构造函数包含在初始化列表中间接初始化继承成员。
```language
class Bulk_item: public Item_base{
public:
	Bulk_item(const string& book, double sales_price, size_t qty, double disc_rate = 0.0):
              Item_base(book, sales_price),
              min_qty(qty), discount(disc_rate) { }
}
```
> 构造函数初始化列表为类的基类和成员提供初始值，它并不指定初始化的执行次序。首先初始化基类，然后根据声明次序初始化派生类的成员。

**4. 在派生类构造函数中使用默认实参**
```language
class Bulk_item: public Item_base{
public:
	Bulk_item(const string& book=““, double sales_price=0.0, size_t qty=0, double disc_rate = 0.0):
              Item_base(book, sales_price),
              min_qty(qty), discount(disc_rate) { }
}
```

**5.只能初始化直接基类**
&emsp;&emsp;一个类只能初始化自己的直接基类。直接基类就是在派生列表中指定的类。

### 15.4.3 复制控制和继承

**1. 定义派生类复制构造函数**
&emsp;&emsp;如果派生类显式定义自己的复制构造函数或赋值操作符，则该定义将完全覆盖默认定义。被继承类的复制构造函数和复制操作符负责对基类成分以及类自己的成员进行复制或赋值。
&emsp;&emsp;如果派生类定义了自己的复制构造函数，则该复制构造函数应该显式调用基类复制构造函数初始化对象的基类部分。
```language
class Base{ /* ... */ }
class Derived: public Base{
public:
	//Base::Base(const Base&) not invoked automatically
    Derived(const Derived& d):
    	Base(d) /* other member initialization */ { /* ... */ }
};
```
如果派生类没有显式调用基类的复制构造函数，如下代码：
```language
Derived(const Derived& d)/* derived memeber initialization */
	{ /* ... */ }
```
将会调用基类的默认构造函数来初始化派生类的基类部分。假定派生类Derived从d中复制对应成员，则新构造的对象将具有奇怪的配置：它的Base部分将保存默认值，而它的Derived成员是另一个对象的副本。
**2. 派生类赋值操作符**
&emsp;&emsp;赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显示赋值。同时需要避免对自身赋值。
```language
Derived& Derived::opertor=(const Derived& rhs)
{
	if (this != &rhs){
    	Base::operator=(rhs);
        // do whatever needed to clean up the old value in the derived part
        // assign the members from the derived
    }
    return *this;
}
```
**3. 派生类析构函数**
&emsp;&emsp;派生类析构函数与复制构造函数和赋值操作符不同，派生类析构函数只负责撤销派生类定义的成员，不负责撤销基类成员。编译器总是显式调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员：
```language
class Derived: public base{
public:
	//Base::~Base invoked automatically
    ~Derived(){ /* do what it takes to clean up derived members */ }
}
```
**4. 虚析构函数**
&emsp;&emsp;在删除指向动态分配的指针的时候，需要运行析构函数在释放对象的内存之前清除对象。处理继承层次的对象时，指针的静态类型可能与被删除对象的动态类型并不相同，可能会只删除实际指向派生类对象的基类部分。为了保证运行合适的析构函数，基类中的析构函数必须为虚函数：
```language
class Item_base{
public:
	// no work, but virtual destructor needed
    // if base pointer that points to derived object is ever deleted
    virtual ~Item_base() { }
}
```
***在复制控制成员中，只有析构函数应该定义为虚函数，构造函数不能定义为虚函数。***构造函数是在对象完全构造之前运行的，在构造函数运行的时候，对象的动态类型还不完整。
&emsp;&emsp;虽然可以在基类中把成员函数operator=定义为虚函数，但是这样做并不影响派生类中使用赋值操作符。基类中创建的复制操作符并没有被派生类重写（即使派生类也定义了赋值操作符），因为他们的形参不同，派生类只是重载了赋值操作符。
### 15.4.5 构造函数和析构函数中的虚函数
&emsp;&emsp;构造派生类对象时首先运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。
&emsp;&emsp;撤销派生类对象时，首先撤销它的派生类部分，然后按照定义次序的逆序撤销它的基类部分。
&emsp;&emsp;在这两种情况下，运行构造函数或析构函数的时候，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在构造函数或析构函数期间，将派生类对象当做基类类型对象对待。

## 15.5继承情况下的类作用域
&emsp;&emsp;每个类都保持自己的作用域，在该作用域中定义成员的名字。在继承的情况下，派生类的作用域嵌套在基类作用域中。如果不能在派生类作用域中确定名字，那么就在外围基类作用域中查找该名字的定义。
### 15.5.1 名字查找在编译时发生
&emsp;&emsp;***对象、引用或指针的静态类型决定了对象能够完成的操作，甚至静态类型和动态类型可能不同的时候***。就像使用基类类型的指针或引用时可能发生的，静态类型仍然决定着可以使用什么成员，比如：把派生类对象赋值给基类引用或指针，该引用或指针仍然不能访问派生类的成员。
```language
class Disc_item: public Item_base{
public:
	std::pair<size_t, double> discount_policy() const 
    { return std::make_pair(quantity, discount); }
    // other members as before
};
Bulk_item bulk;
Bulk_item *bulk_p = &bulk;
Item_base *item_p = &bulk;
bulk_p->discount_policy();  // ok:bulk_p has type Bulk_item*
item_p->discount_policy();  // error:item_p has type Item_base*
```
### 15.5.2 数据成员名字冲突与继承
&emsp;&emsp;虽然可以直接访问基类成员，就像它是派生类成员一样，但是成员保留了它的基类成员资格。一般我们并不关心哪个类定义了该成员，通常只在基类和派生类共享同一名字时才需要注意。当派生类数据成员和基类数据成员同名时将屏蔽对基类成员的直接访问，但是可以通过作用域操作符间接访问。

### 15.5.3 作用域与成员函数
***虚函数动态绑定，非虚函数相互覆盖***
&emsp;&emsp;在基类和派生类中使用同一名字的成员函数，其行为与数据成员一致：在派生类作用域中的成员将屏蔽基类中的成员，即使函数原型不同，也就是说即使同名、形参个数和类型不同也会被覆盖。比如：
```language
struct Base{
	int memfcn();
};
struct Derived: Base{
	int memfcn(int);
};
Derived d;
Base b;
b.memfcn();
d.memfcn(10);
d.memfcn(); // error: memfcn with no arguments is hidden
d.Base::memfcn();
```
第三个调用：d.memfcn()，要确定这个调用，编译器需要查找名字memfcn，在Derived类中找到了。一旦找到，编译器就不会继续查找了。这个调用与Derived中定义的不匹配，故报错。
> 局部作用域声明的函数不会重载全局作用域中定义的函数，同样，派生类中定义的函数也不重载基类中定义的成员。通过派生类对象调用函数的时候，实参必须与派生类中定义的相匹配。只有在派生类中没有定义该函数才考虑基类函数。

成员函数也可以重载。***如果派生类对某个成员函数进行重载，那么派生类对象只能访问派生类中重定义的那些成员***。如果派生类想通过自身类型使用所有的重载版本，则派生类要么重定义所有重载版本，要么一个也别定义。但是有时需要在派生类中重载某个成员函数，又想使用基类中其他重载函数，又不想重定义基类中的其他重载函数。派生类可以使用using声明。一个using声明只能指定一个名字，不能指定形参表，同15.2.3节中相似。
### 虚函数与作用域
要获得动态绑定，必须通过基类的引用或指针调用虚函数。当我们这样做时，编译器将在基类中查找函数。如果找到了名字，编译器就检查实参和形参是否匹配。
现在可以理解虚函数为什么要求在基类和派生类中拥有同一原型了。如果基类成员与派生类成员接受的实参不同，就没有办法通过基类类型的指针或引用调用派生类的函数。***如果派生类没有重新定义基类中的虚函数，则派生类使用基类中的虚函数，这是没有动态绑定***。
```language
class Base{
public: 
	Virtual int fcn();
};
class D1: public Base{
public:
	int fcn(int);
};
class D2: public D1{
public:
	int fcn(int);
    int fcn();
};
```
D1没有重定义基类的虚函数fcn，相反，它屏蔽了基类的fcn。结果D1有两个名为fcn的函数：类从Base继承了一个名为fcn的函数，类又定义了自己的非虚fcn成员函数，该函数接受一个int形参。但是，从Base继承的虚函数不能通过D1对象调用，因为该函数被fcn(int)的定义屏蔽了。类D2重定义了它继承的两个函数，它重定义了Base中定义的fcn的原始版本并重定义了D1中定义的非虚版本。
***通过基类类型的引用或指针调用函数时，编译器将在基类中查找该函数而忽略派生类***。
```language
Base bobj;
D1 d1;
D2 d2;
Base *bp = &bobj;
Base *bd1 = &d1;
Base &bd2 = &d2;
bp->fcn();   // ok: virtual call, will call Base::fcn at run time
bd1->fcn();  // ok: virtual call, will call Base::fcn at run time
bd2->fcn();  // ok: virtual call, will call D2::fcn at run time
```
> 理解C++中继承层次的关键在于理解如何确定函数调用。确定函数调用遵循以下四个步骤：
> （1） 首先确定进行函数调用的对象、引用或指针的静态类型；
> （2） 在该类中查找函数，如果找不到，就在直接基类中查找，如此循着类的继承链往上找，直到找到该函数或者查找完最后一个类。如果不能在类或相关基类中找到改名字，则调用时错误的；
> （3） 一旦找到了该名字，就进行常规类型检查，查看实参是否与形参匹配；
> （4） 假定函数调用合法，编译器就生成代码。如果函数是虚函数且通过引用或指针调用，则编译器生成代码以确定根据对象的动态类型运行哪一个函数版本，否则编译器生成代码直接调用函数。

## 15.6 纯虚函数
&emsp;&emsp;含有一个或多个纯虚函数的类是抽象基类（abstract base class）。除了作为抽象基类的派生类的对象的组成部分，不能创建抽象类型的对象。纯虚函数为函数形参表后面写上“=0”的成员函数。比如：
```language
class Disc_item: public Item_base{
public: 
	double net_price(size_t) const=0;
}
类Disc_item为抽象基类，net_price为纯虚函数
```





























